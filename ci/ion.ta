util:
    exists:      import 'tapestry' string > bool
    folders:     import 'tapestry' string > [path]
    overlay:     import 'tapestry' string string > bool

regex:
    match:       import 'tapestry' string string u32 > string

path:
    src:         string
    
    stem:        method
        # if we call this with just path.stem it would throw an error (undefined read)
        regex.match src /^[^.]*/
    
    ext:         method
        return regex.match src /\.([^.]*)$/
    
    exists:      method
        util.exists src

    overlay:     method dest:string
        util.overlay dest src

project:[path this].stem

# 'var' object type is implicit here, but we are essentially using that
externs:
    glm:'https://github.com/g-truc/glm@bf71a83'
        args: ['-DBUILD_STATIC_LIBS=1']

# once a type is made, it would conflict to use it as a variable name
externs.each > e:
    name: e.key
    path extern: 'extern/$name'

    # should support any manner of operation set here, !!e || (e ^ f) for example
    !extern.exists: 
        $(git clone $url $extern) 

folders:util.folders '*'
folders.each > folder:
    path:       folder.src
    module:     folder.stem
    spin path module '$project-$module'
        name:       spin.name
        module:     spin.module
        src:        spin.src
        cc:         'gcc'
        objects:    []

        # are defining a function here, but we dont actually have to have a separate syntax
        args_for: method file 
            file.ext == 'c':
                args: '-std=c11'
            file.ext == 'cpp':
                args: '-std=c++17'
        
        src.each > file:
            object: file.add_ext '.o'
            file.date.exceeds object.date:
                exit_code: $($cc $args -c $file -o $file.o)
                exit_code == 0:
                    objects: objects $file.o

        ar: $(ar rcs $objects)
        ar != 0:
            fail:
                exit_code:-1
                print:'static .a archive creation exit code: $ar'   # should break the entire process and return failure


        # read info on targets in this module (no abstract rel path for this level)
        # path.json 'targets.json': data
        #    data.apps.each: app as file # cast to a different type in the tree; json is typeless; a new var calling a method is casting a type to receive its variable
        #        compile: $($cc $args_for:app) 
        #        compile != 0:
        #            fail:'app compile exit code: $?'